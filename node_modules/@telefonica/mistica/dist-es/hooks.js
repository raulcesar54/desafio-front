import * as n from "react";
import I from "./theme-context.js";
import E from "./screen-size-context.js";
import H from "./aria-id-getter-context.js";
import { listenResize as T } from "./utils/dom.js";
import { isClientSide as l } from "./utils/environment.js";
import { isEqual as R } from "./utils/helpers.js";
const C = ()=>{
    const t = n.useContext(I);
    if (!t) throw Error("To use @telefonica/mistica components you must instantiate <ThemeContextProvider> as their parent.");
    return t;
};
let f = "", S = 0, g = 0;
const M = (t)=>{
    n.useEffect(()=>{
        if (t) {
            const r = document.scrollingElement || document.documentElement, e = ()=>{
                var i;
                var _ref, _ref1;
                if (g++, !(g > 1) && (S = (_ref = r == null ? void 0 : r.scrollTop) !== null && _ref !== void 0 ? _ref : 0, f = (_ref1 = (i = document.body) == null ? void 0 : i.style.cssText) !== null && _ref1 !== void 0 ? _ref1 : "", document.body)) {
                    var _ref2;
                    const o = window.innerWidth > ((_ref2 = r == null ? void 0 : r.clientWidth) !== null && _ref2 !== void 0 ? _ref2 : window.innerWidth) ? "scroll" : "hidden";
                    document.body.style.cssText = f + (f.endsWith(";") ? "" : ";") + [
                        "overflow: hidden;",
                        `overflow-y: ${o};`,
                        "position: fixed;",
                        `top: ${-S}px;`,
                        "left: 0px;",
                        "right: 0px;",
                        "bottom: 0px;",
                        "overscroll-behavior-y: contain;"
                    ].join("");
                }
            }, c = ()=>{
                g--, !(g > 0) && (document.body && (document.body.style.cssText = f), r && (r.scrollTop = S));
            };
            return e(), c;
        }
        return ()=>{};
    }, [
        t
    ]);
}, k = ()=>n.useContext(E), F = function() {
    let { includeMargins: t = !1 } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const [r, e] = n.useState(0), [c, i] = n.useState(0), [s, o] = n.useState(null), d = n.useCallback((a)=>{
        if (!a) {
            e(0), i(0);
            return;
        }
        const { width: w, height: m } = a[0].contentRect;
        if (t) {
            const h = window.getComputedStyle(a[0].target), v = parseInt(h.marginTop, 10), b = parseInt(h.marginBottom, 10), W = parseInt(h.marginLeft, 10), x = parseInt(h.marginRight, 10);
            e(w + W + x), i(m + v + b);
        } else e(w), i(m);
    }, [
        t
    ]), u = n.useCallback((a)=>{
        o(a);
    }, []);
    return n.useEffect(()=>{
        if (!s) {
            e(0), i(0);
            return;
        }
        return T(s, d);
    }, [
        s,
        d
    ]), {
        width: r,
        height: c,
        ref: u
    };
}, $ = (t)=>{
    const { useId: r } = C();
    if (r) {
        const e = r();
        return t || e;
    } else {
        const e = n.useContext(H);
        return n.useRef(t || e()).current;
    }
}, y = ()=>{
    var w;
    const [t, r] = n.useState(l() ? window.innerHeight : 1200), [e, c] = n.useState(l() ? window.innerWidth : 800), [i, s] = n.useState(l() ? window.screen.availHeight : 1200), [o, d] = n.useState(l() ? window.screen.availWidth : 800), [u, a] = n.useState(l() ? ((w = window.visualViewport) == null ? void 0 : w.height) || window.screen.availHeight : 1200);
    return n.useEffect(()=>{
        const m = ()=>{
            var h;
            r(window.innerHeight), c(window.innerWidth), s(window.screen.availHeight), d(window.screen.availWidth), a(((h = window.visualViewport) == null ? void 0 : h.height) || window.screen.availHeight);
        };
        return window.addEventListener("resize", m), ()=>{
            window.removeEventListener("resize", m);
        };
    }, []), n.useMemo(()=>({
            height: t,
            width: e,
            screenHeight: i,
            screenWidth: o,
            visualHeight: u
        }), [
        t,
        e,
        i,
        o,
        u
    ]);
}, j = ()=>{
    const { height: t } = y();
    return t;
}, G = ()=>{
    const { width: t } = y();
    return t;
}, O = l() ? n.useLayoutEffect : n.useEffect, B = (t, r, e)=>{
    const [c, i] = n.useState(r);
    return n.useEffect(()=>{
        if (!t.current) return;
        if (typeof window.IntersectionObserver > "u") return ()=>{};
        const s = new IntersectionObserver((o)=>{
            i(o[0].isIntersecting);
        }, {
            root: e == null ? void 0 : e.root,
            rootMargin: e == null ? void 0 : e.rootMargin,
            threshold: e == null ? void 0 : e.threshold
        });
        return s.observe(t.current), ()=>{
            s.disconnect();
        };
    }, [
        t,
        e == null ? void 0 : e.root,
        e == null ? void 0 : e.rootMargin,
        e == null ? void 0 : e.threshold
    ]), c;
}, z = (t)=>{
    const { top: r, right: e, bottom: c, left: i, width: s, height: o, x: d, y: u } = t.getBoundingClientRect();
    return {
        top: r,
        right: e,
        bottom: c,
        left: i,
        width: s,
        height: o,
        x: d,
        y: u
    };
}, P = function(t) {
    let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0, e = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
    const [c, i] = n.useState(), s = B(t, !1);
    return n.useEffect(()=>{
        let o;
        const d = ()=>{
            if (t.current && (s || e)) {
                const u = z(t.current);
                R(c, u) || i(u), r && (o = requestAnimationFrame(d));
            } else i(void 0);
        };
        return o = requestAnimationFrame(d), ()=>{
            cancelAnimationFrame(o);
        };
    }, [
        t,
        c,
        s,
        r,
        e
    ]), c;
};
export { $ as useAriaId, P as useBoundingRect, M as useDisableBodyScroll, F as useElementDimensions, B as useIsInViewport, O as useIsomorphicLayoutEffect, k as useScreenSize, C as useTheme, j as useWindowHeight, y as useWindowSize, G as useWindowWidth };
