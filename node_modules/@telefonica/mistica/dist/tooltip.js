"use client";
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    BaseTooltip: function() {
        return jt;
    },
    default: function() {
        return ge;
    }
});
const _jsxruntime = require("react/jsx-runtime");
const _react = /*#__PURE__*/ _interop_require_wildcard(require("react"));
const _hooks = require("./hooks.js");
const _portal = require("./portal.js");
const _reacttransitiongroup = require("react-transition-group");
const _tooltipcssmistica = require("./tooltip.css-mistica.js");
const _stack = /*#__PURE__*/ _interop_require_default(require("./stack.js"));
const _text = require("./text.js");
const _dom = require("./utils/dom.js");
const _keys = require("./utils/keys.js");
const _environment = require("./utils/environment.js");
const _helpers = require("./utils/helpers.js");
const _classnames = /*#__PURE__*/ _interop_require_default(require("classnames"));
const _skincontractcssmistica = require("./skins/skin-contract.css-mistica.js");
const _themevariantcontext = require("./theme-variant-context.js");
const _common = require("./utils/common.js");
const _tooltipcontextprovider = require("./tooltip-context-provider.js");
const _platform = require("./utils/platform.js");
const _iconbutton = require("./icon-button.js");
const _iconcloseregular = /*#__PURE__*/ _interop_require_default(require("./generated/mistica-icons/icon-close-regular.js"));
const _box = /*#__PURE__*/ _interop_require_default(require("./box.js"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _object_spread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
                return Object.getOwnPropertyDescriptor(source, sym).enumerable;
            }));
        }
        ownKeys.forEach(function(key) {
            _define_property(target, key, source[key]);
        });
    }
    return target;
}
function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) {
            symbols = symbols.filter(function(sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
        }
        keys.push.apply(keys, symbols);
    }
    return keys;
}
function _object_spread_props(target, source) {
    source = source != null ? source : {};
    if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
        ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
    }
    return target;
}
function _object_without_properties(source, excluded) {
    if (source == null) return {};
    var target = _object_without_properties_loose(source, excluded);
    var key, i;
    if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for(i = 0; i < sourceSymbolKeys.length; i++){
            key = sourceSymbolKeys[i];
            if (excluded.indexOf(key) >= 0) continue;
            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
            target[key] = source[key];
        }
    }
    return target;
}
function _object_without_properties_loose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for(i = 0; i < sourceKeys.length; i++){
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        target[key] = source[key];
    }
    return target;
}
const lt = (t)=>({
        border: `1px solid ${t ? _skincontractcssmistica.vars.colors.backgroundContainer : _skincontractcssmistica.vars.colors.border}`
    }), ct = 496, Yt = 300, Gt = 500, Kt = 100, p = 20, w = 6, N = w + p / 2 + 1, Ut = (t)=>{
    switch(t){
        case "left":
            return `translateX(-${w}px)`;
        case "right":
            return `translateX(${w}px)`;
        case "top":
            return `translateY(-${w}px)`;
        case "bottom":
            return `translateY(${w}px)`;
        default:
            return "";
    }
}, pt = (t)=>{
    const h = parseFloat(getComputedStyle(t, null).paddingLeft) + parseFloat(getComputedStyle(t, null).paddingRight), v = parseFloat(getComputedStyle(t, null).paddingTop) + parseFloat(getComputedStyle(t, null).paddingBottom), d = t.offsetWidth - h, m = t.offsetHeight - v;
    return {
        width: d,
        height: m
    };
}, ft = (t, h, v, d, m)=>{
    if (!t || !h) return;
    const { top: x, bottom: I, left: B, right: W } = t, o = d - I, O = m - W, R = x, a = B, { width: X, height: V } = pt(h), _ = X + N, T = V + N, b = _ <= Math.max(a, O), M = T <= Math.max(o, R);
    if (!(!M && !b)) switch(v){
        case "left":
            return b ? _ <= a ? "left" : "right" : o > R ? "bottom" : "top";
        case "right":
            return b ? _ <= O ? "right" : "left" : o > R ? "bottom" : "top";
        case "top":
            return M ? T <= R ? "top" : "bottom" : a > O ? "left" : "right";
        case "bottom":
            return M ? T <= o ? "bottom" : "top" : a > O ? "left" : "right";
        default:
            return;
    }
}, jt = (param)=>{
    let { content: t, target: h, width: v, position: d = "top", dataAttributes: m, delay: x = !0, centerContent: I, open: B, onClose: W, hasPointerInteractionOnly: o = !1, trackingEvent: O } = param;
    const { texts: R } = (0, _hooks.useTheme)(), a = (0, _hooks.useAriaId)(), { openTooltipId: X } = (0, _tooltipcontextprovider.useTooltipState)(), { openTooltip: V, closeTooltip: _ } = (0, _tooltipcontextprovider.useSetTooltipState)(), [T, b] = _react.useState(), [M, z] = _react.useState(), P = _react.useRef(null), Y = _react.useRef(null), [C, dt] = _react.useState(null), u = (0, _environment.isTouchableDevice)(), G = x ? Gt : 0, [et, K] = _react.useState(!1), [U, y] = _react.useState(!1), j = B !== void 0, [ot, q] = _react.useState(!1), E = j ? B : a === X, Z = (0, _themevariantcontext.useIsInverseVariant)(), f = (0, _hooks.useBoundingRect)(P, E), H = (0, _hooks.useBoundingRect)(Y, E, !0), l = (0, _hooks.useWindowSize)(), S = _react.useCallback(()=>{
        q(!1), K(!1), y(!1);
    }, []);
    _react.useEffect(()=>{
        E || S();
    }, [
        E,
        S
    ]), _react.useEffect(()=>{
        if (!C || !E) return;
        const s = ft(f, C, d, l.height, l.width);
        if (!s || !f) {
            b(void 0), z(void 0), S();
            return;
        }
        let r, e;
        var _parseInt;
        const { left: c, right: k, top: L, bottom: A } = f, { width: $, height: F } = pt(C), rt = l.width - $, st = l.height - F, g = (_parseInt = parseInt((0, _dom.getCssVarValue)(_skincontractcssmistica.vars.borderRadii.popup))) !== null && _parseInt !== void 0 ? _parseInt : 8;
        switch(s){
            case "top":
                r = {
                    left: Math.max(0, Math.min(rt, (c + k - $) / 2)),
                    top: L - F - p / 2,
                    padding: `0px 0px ${N}px 0px`
                }, e = {
                    left: Math.max(g, Math.min(l.width - g - p, (c + k - p) / 2)),
                    top: "100%"
                };
                break;
            case "bottom":
                r = {
                    left: Math.max(0, Math.min(rt, (c + k - $) / 2)),
                    top: A - w,
                    padding: `${N}px 0px 0px 0px`
                }, e = {
                    left: Math.max(g, Math.min(l.width - g - p, (c + k - p) / 2)),
                    bottom: "100%",
                    transform: "rotate(180deg)"
                };
                break;
            case "left":
                r = {
                    left: c - $ - p / 2,
                    top: Math.max(0, Math.min(st, (L + A - F) / 2)),
                    padding: `0px ${N}px 0px 0px`
                }, e = {
                    top: Math.max(g, Math.min(l.height - g - p, (L + A - p) / 2)),
                    left: "100%",
                    transform: "rotate(-90deg)",
                    transformOrigin: "bottom"
                };
                break;
            case "right":
            default:
                r = {
                    left: k - w,
                    top: Math.max(0, Math.min(st, (L + A - F) / 2)),
                    padding: `0px 0px 0px ${N}px`
                }, e = {
                    top: Math.max(g, Math.min(l.height - g - p, (L + A - p) / 2)),
                    right: "100%",
                    transform: "rotate(90deg)",
                    transformOrigin: "bottom"
                };
                break;
        }
        typeof e.top == "number" && (e.top -= r.top, e.top = `${e.top / F * 100}%`), typeof e.left == "number" && (e.left -= r.left, e.left = `${e.left / $ * 100}%`), (0, _helpers.isEqual)(r, T) || b(r), (0, _helpers.isEqual)(e, M) || z(e);
    }, [
        C,
        f,
        H,
        E,
        d,
        l,
        T,
        M,
        Z,
        u,
        a,
        S
    ]);
    const J = _react.useRef(!1);
    _react.useEffect(()=>{
        const s = (c)=>{
            switch(c.key){
                case _keys.ESC:
                    o || S();
                    break;
                case _keys.TAB:
                    J.current = !0;
                    break;
            }
        }, r = ()=>J.current = !1, e = (c)=>{
            !o && u && f && (c.clientX < f.left || c.clientX > f.right || c.clientY < f.top || c.clientY > f.bottom) && S();
        };
        return document.addEventListener("keydown", s, !1), document.addEventListener("keyup", r, !1), document.addEventListener("click", e, !1), ()=>{
            document.removeEventListener("keydown", s, !1), document.removeEventListener("keyup", r, !1), document.removeEventListener("click", e, !1);
        };
    }, [
        u,
        S,
        f,
        o
    ]), _react.useEffect(()=>{
        j || (U || et || ot ? V(a) : _(a));
    }, [
        U,
        et,
        ot,
        a,
        V,
        _,
        j
    ]);
    const mt = ft(f, C, d, l.height, l.width), ut = I !== void 0 ? I : (H == null ? void 0 : H.width) === _tooltipcssmistica.CONTENT_MIN_WIDTH;
    return /* @__PURE__ */ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {
        children: [
            /* @__PURE__ */ (0, _jsxruntime.jsx)("div", {
                ref: (s)=>{
                    const r = s == null ? void 0 : s.firstElementChild;
                    r && r !== P.current && (P.current = r);
                },
                onMouseOver: ()=>{
                    !u && !o && y(!0);
                },
                onMouseLeave: ()=>{
                    !u && !o && y(!1);
                },
                onClick: ()=>{
                    (u || o) && y(o ? !U : !0);
                },
                onFocus: ()=>{
                    J.current && !o && q(!0);
                },
                onBlur: ()=>{
                    !u && !o && q(!1);
                },
                "aria-describedby": a,
                children: h
            }),
            /* @__PURE__ */ (0, _jsxruntime.jsx)(_portal.Portal, {
                children: /* @__PURE__ */ (0, _jsxruntime.jsx)(_reacttransitiongroup.Transition, {
                    in: E,
                    nodeRef: Y,
                    timeout: (0, _platform.isRunningAcceptanceTest)() ? 0 : {
                        enter: Yt + G,
                        exit: Kt
                    },
                    onExited: ()=>{
                        b(void 0), z(void 0);
                    },
                    mountOnEnter: !0,
                    unmountOnExit: !0,
                    children: (s)=>/* @__PURE__ */ (0, _jsxruntime.jsx)("div", _object_spread_props(_object_spread({
                            style: {
                                /**
               * Hack to prevent text from wrapping automatically when touching the viewport's edges,
               * even if the content's width didn't reach the max width.
               * https://stackoverflow.com/questions/66106629/how-to-disable-text-wrapping-when-viewport-border-is-reached
               */ width: `calc(100vw + ${ct}px)`,
                                top: 0,
                                left: 0,
                                position: "fixed",
                                visibility: T ? "visible" : "hidden"
                            }
                        }, m), {
                            role: "tooltip",
                            "aria-label": a,
                            tabIndex: -1,
                            children: /* @__PURE__ */ (0, _jsxruntime.jsx)("div", {
                                className: (0, _classnames.default)(_tooltipcssmistica.container),
                                style: _object_spread_props(_object_spread({
                                    pointerEvents: s === "entered" ? "auto" : "none",
                                    transform: Ut(mt)
                                }, T, _tooltipcssmistica.tooltipTransitionClasses[s]), {
                                    transition: s === "entering" ? `opacity .1s linear ${G}ms,transform .3s cubic-bezier(0.215,0.61,0.335,1) ${G}ms` : "opacity .1s linear"
                                }),
                                ref: (0, _common.combineRefs)(dt, Y),
                                onMouseEnter: ()=>{
                                    !u && s === "entered" && !o && K(!0);
                                },
                                onMouseLeave: ()=>{
                                    !u && !o && K(!1);
                                },
                                children: /* @__PURE__ */ (0, _jsxruntime.jsxs)("div", {
                                    className: _tooltipcssmistica.tooltip,
                                    style: _object_spread_props(_object_spread({
                                        width: v
                                    }, lt(Z)), {
                                        maxWidth: Math.min(ct, l.width)
                                    }),
                                    children: [
                                        /* @__PURE__ */ (0, _jsxruntime.jsx)("div", {
                                            className: (0, _classnames.default)(_tooltipcssmistica.contentContainer, {
                                                [_tooltipcssmistica.tooltipCenter]: ut
                                            }),
                                            children: /* @__PURE__ */ (0, _jsxruntime.jsxs)(_themevariantcontext.ThemeVariant, {
                                                isInverse: !1,
                                                children: [
                                                    t,
                                                    W && /* @__PURE__ */ (0, _jsxruntime.jsx)("div", {
                                                        className: _tooltipcssmistica.closeButtonIcon,
                                                        children: /* @__PURE__ */ (0, _jsxruntime.jsx)(_iconbutton.IconButton, {
                                                            onPress: ()=>{
                                                                y(!1), W();
                                                            },
                                                            trackingEvent: O,
                                                            "aria-label": R.modalClose,
                                                            Icon: _iconcloseregular.default,
                                                            small: !0
                                                        })
                                                    })
                                                ]
                                            })
                                        }),
                                        /* @__PURE__ */ (0, _jsxruntime.jsx)("div", {
                                            className: _tooltipcssmistica.arrowContainer,
                                            style: M,
                                            children: /* @__PURE__ */ (0, _jsxruntime.jsx)("div", {
                                                className: (0, _classnames.default)(_tooltipcssmistica.arrow),
                                                style: lt(Z)
                                            })
                                        })
                                    ]
                                })
                            })
                        }))
                })
            })
        ]
    });
}, qt = (_param)=>{
    var { centerContent: t, extra: h, children: v, dataAttributes: d, title: m, description: x } = _param, I = _object_without_properties(_param, [
        "centerContent",
        "extra",
        "children",
        "dataAttributes",
        "title",
        "description"
    ]);
    return /* @__PURE__ */ (0, _jsxruntime.jsx)(jt, _object_spread({
        content: /* @__PURE__ */ (0, _jsxruntime.jsxs)(_box.default, {
            className: _tooltipcssmistica.content,
            children: [
                (m || x) && /* @__PURE__ */ (0, _jsxruntime.jsxs)(_stack.default, {
                    space: 4,
                    children: [
                        m && /* @__PURE__ */ (0, _jsxruntime.jsx)(_text.Text2, {
                            medium: !0,
                            children: m
                        }),
                        x && /* @__PURE__ */ (0, _jsxruntime.jsx)(_text.Text2, {
                            regular: !0,
                            children: x
                        })
                    ]
                }),
                h !== null && h !== void 0 ? h : v
            ]
        }),
        centerContent: t,
        dataAttributes: _object_spread({
            "component-name": "Tooltip"
        }, d)
    }, I));
}, ge = qt;
