"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    useAriaId: function() {
        return $;
    },
    useBoundingRect: function() {
        return P;
    },
    useDisableBodyScroll: function() {
        return M;
    },
    useElementDimensions: function() {
        return F;
    },
    useIsInViewport: function() {
        return B;
    },
    useIsomorphicLayoutEffect: function() {
        return O;
    },
    useScreenSize: function() {
        return k;
    },
    useTheme: function() {
        return C;
    },
    useWindowHeight: function() {
        return j;
    },
    useWindowSize: function() {
        return y;
    },
    useWindowWidth: function() {
        return G;
    }
});
const _react = /*#__PURE__*/ _interop_require_wildcard(require("react"));
const _themecontext = /*#__PURE__*/ _interop_require_default(require("./theme-context.js"));
const _screensizecontext = /*#__PURE__*/ _interop_require_default(require("./screen-size-context.js"));
const _ariaidgettercontext = /*#__PURE__*/ _interop_require_default(require("./aria-id-getter-context.js"));
const _dom = require("./utils/dom.js");
const _environment = require("./utils/environment.js");
const _helpers = require("./utils/helpers.js");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const C = ()=>{
    const t = _react.useContext(_themecontext.default);
    if (!t) throw Error("To use @telefonica/mistica components you must instantiate <ThemeContextProvider> as their parent.");
    return t;
};
let f = "", S = 0, g = 0;
const M = (t)=>{
    _react.useEffect(()=>{
        if (t) {
            const r = document.scrollingElement || document.documentElement, e = ()=>{
                var i;
                var _ref, _ref1;
                if (g++, !(g > 1) && (S = (_ref = r == null ? void 0 : r.scrollTop) !== null && _ref !== void 0 ? _ref : 0, f = (_ref1 = (i = document.body) == null ? void 0 : i.style.cssText) !== null && _ref1 !== void 0 ? _ref1 : "", document.body)) {
                    var _ref2;
                    const o = window.innerWidth > ((_ref2 = r == null ? void 0 : r.clientWidth) !== null && _ref2 !== void 0 ? _ref2 : window.innerWidth) ? "scroll" : "hidden";
                    document.body.style.cssText = f + (f.endsWith(";") ? "" : ";") + [
                        "overflow: hidden;",
                        `overflow-y: ${o};`,
                        "position: fixed;",
                        `top: ${-S}px;`,
                        "left: 0px;",
                        "right: 0px;",
                        "bottom: 0px;",
                        "overscroll-behavior-y: contain;"
                    ].join("");
                }
            }, c = ()=>{
                g--, !(g > 0) && (document.body && (document.body.style.cssText = f), r && (r.scrollTop = S));
            };
            return e(), c;
        }
        return ()=>{};
    }, [
        t
    ]);
}, k = ()=>_react.useContext(_screensizecontext.default), F = function() {
    let { includeMargins: t = !1 } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const [r, e] = _react.useState(0), [c, i] = _react.useState(0), [s, o] = _react.useState(null), d = _react.useCallback((a)=>{
        if (!a) {
            e(0), i(0);
            return;
        }
        const { width: w, height: m } = a[0].contentRect;
        if (t) {
            const h = window.getComputedStyle(a[0].target), v = parseInt(h.marginTop, 10), b = parseInt(h.marginBottom, 10), W = parseInt(h.marginLeft, 10), x = parseInt(h.marginRight, 10);
            e(w + W + x), i(m + v + b);
        } else e(w), i(m);
    }, [
        t
    ]), u = _react.useCallback((a)=>{
        o(a);
    }, []);
    return _react.useEffect(()=>{
        if (!s) {
            e(0), i(0);
            return;
        }
        return (0, _dom.listenResize)(s, d);
    }, [
        s,
        d
    ]), {
        width: r,
        height: c,
        ref: u
    };
}, $ = (t)=>{
    const { useId: r } = C();
    if (r) {
        const e = r();
        return t || e;
    } else {
        const e = _react.useContext(_ariaidgettercontext.default);
        return _react.useRef(t || e()).current;
    }
}, y = ()=>{
    var w;
    const [t, r] = _react.useState((0, _environment.isClientSide)() ? window.innerHeight : 1200), [e, c] = _react.useState((0, _environment.isClientSide)() ? window.innerWidth : 800), [i, s] = _react.useState((0, _environment.isClientSide)() ? window.screen.availHeight : 1200), [o, d] = _react.useState((0, _environment.isClientSide)() ? window.screen.availWidth : 800), [u, a] = _react.useState((0, _environment.isClientSide)() ? ((w = window.visualViewport) == null ? void 0 : w.height) || window.screen.availHeight : 1200);
    return _react.useEffect(()=>{
        const m = ()=>{
            var h;
            r(window.innerHeight), c(window.innerWidth), s(window.screen.availHeight), d(window.screen.availWidth), a(((h = window.visualViewport) == null ? void 0 : h.height) || window.screen.availHeight);
        };
        return window.addEventListener("resize", m), ()=>{
            window.removeEventListener("resize", m);
        };
    }, []), _react.useMemo(()=>({
            height: t,
            width: e,
            screenHeight: i,
            screenWidth: o,
            visualHeight: u
        }), [
        t,
        e,
        i,
        o,
        u
    ]);
}, j = ()=>{
    const { height: t } = y();
    return t;
}, G = ()=>{
    const { width: t } = y();
    return t;
}, O = (0, _environment.isClientSide)() ? _react.useLayoutEffect : _react.useEffect, B = (t, r, e)=>{
    const [c, i] = _react.useState(r);
    return _react.useEffect(()=>{
        if (!t.current) return;
        if (typeof window.IntersectionObserver > "u") return ()=>{};
        const s = new IntersectionObserver((o)=>{
            i(o[0].isIntersecting);
        }, {
            root: e == null ? void 0 : e.root,
            rootMargin: e == null ? void 0 : e.rootMargin,
            threshold: e == null ? void 0 : e.threshold
        });
        return s.observe(t.current), ()=>{
            s.disconnect();
        };
    }, [
        t,
        e == null ? void 0 : e.root,
        e == null ? void 0 : e.rootMargin,
        e == null ? void 0 : e.threshold
    ]), c;
}, z = (t)=>{
    const { top: r, right: e, bottom: c, left: i, width: s, height: o, x: d, y: u } = t.getBoundingClientRect();
    return {
        top: r,
        right: e,
        bottom: c,
        left: i,
        width: s,
        height: o,
        x: d,
        y: u
    };
}, P = function(t) {
    let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0, e = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
    const [c, i] = _react.useState(), s = B(t, !1);
    return _react.useEffect(()=>{
        let o;
        const d = ()=>{
            if (t.current && (s || e)) {
                const u = z(t.current);
                (0, _helpers.isEqual)(c, u) || i(u), r && (o = requestAnimationFrame(d));
            } else i(void 0);
        };
        return o = requestAnimationFrame(d), ()=>{
            cancelAnimationFrame(o);
        };
    }, [
        t,
        c,
        s,
        r,
        e
    ]), c;
};
