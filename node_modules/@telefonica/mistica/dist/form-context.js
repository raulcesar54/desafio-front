"use client";
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    FormContext: function() {
        return k;
    },
    useControlProps: function() {
        return y;
    },
    useFieldProps: function() {
        return z;
    },
    useForm: function() {
        return P;
    }
});
const _react = /*#__PURE__*/ _interop_require_wildcard(require("react"));
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const k = /*#__PURE__*/ _react.createContext({
    values: {},
    setValue: ()=>{},
    rawValues: {},
    setRawValue: ()=>{},
    formStatus: "filling",
    register: ()=>{},
    formErrors: {},
    setFormError: ()=>{},
    jumpToNext: ()=>{},
    submit: ()=>{},
    validate: ()=>({}),
    formId: ""
}), P = ()=>_react.useContext(k), y = (param)=>{
    let { name: r, value: t, defaultValue: e, onChange: u, disabled: p } = param;
    const { setRawValue: l, setValue: w, rawValues: o, setFormError: E, register: f, formStatus: R } = P();
    var _o_r;
    return _react.useEffect(()=>{
        if (o[r] === void 0) {
            var _ref;
            const s = (_ref = t !== null && t !== void 0 ? t : e) !== null && _ref !== void 0 ? _ref : !1;
            w({
                name: r,
                value: s
            }), l({
                name: r,
                value: s
            });
        }
    }, [
        t,
        r,
        e,
        o,
        w,
        l
    ]), {
        name: r,
        value: t,
        defaultValue: e !== null && e !== void 0 ? e : t === void 0 ? (_o_r = o[r]) !== null && _o_r !== void 0 ? _o_r : !1 : void 0,
        focusableRef: (s)=>f(r, {
                focusableElement: s
            }),
        onChange: (s)=>{
            l({
                name: r,
                value: s
            }), w({
                name: r,
                value: s
            }), E({
                name: r,
                error: ""
            }), u == null || u(s);
        },
        disabled: R === "sending" || p
    };
}, z = (param)=>{
    let { name: r, value: t, defaultValue: e, processValue: u, helperText: p, optional: l, error: w, disabled: o, onBlur: E, validate: f, onChange: R, onChangeValue: s } = param;
    var _ref, _ref1;
    const { setRawValue: v, setValue: V, rawValues: x, values: j, formErrors: T, formStatus: q, setFormError: d, register: I } = P(), F = (_ref1 = (_ref = t !== null && t !== void 0 ? t : e) !== null && _ref !== void 0 ? _ref : x[r]) !== null && _ref1 !== void 0 ? _ref1 : "", N = _react.useRef(u);
    var _x_r;
    return _react.useEffect(()=>{
        v({
            name: r,
            value: F
        }), V({
            name: r,
            value: N.current(F)
        });
    }, [
        r,
        F,
        v,
        V
    ]), _react.useEffect(()=>{
        o && d({
            name: r,
            error: void 0
        });
    }, [
        o,
        r,
        d
    ]), {
        value: t,
        defaultValue: e !== null && e !== void 0 ? e : t === void 0 ? (_x_r = x[r]) !== null && _x_r !== void 0 ? _x_r : "" : void 0,
        name: r,
        helperText: T[r] || p,
        required: !l,
        error: w || !!T[r],
        disabled: o || q === "sending",
        onBlur: (i)=>{
            d({
                name: r,
                error: f == null ? void 0 : f(j[r], x[r])
            }), E == null || E(i);
        },
        inputRef: (i)=>I(r, {
                input: i,
                validator: f
            }),
        onChange: (i)=>{
            const S = i.currentTarget.value, b = u(S);
            v({
                name: r,
                value: S
            }), V({
                name: r,
                value: b
            }), d({
                name: r,
                error: ""
            }), R == null || R(i), s == null || s(b, S);
        }
    };
};
