"use client";
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    RATIO: function() {
        return K;
    },
    default: function() {
        return re;
    }
});
const _jsxruntime = require("react/jsx-runtime");
const _react = /*#__PURE__*/ _interop_require_wildcard(require("react"));
const _image = require("./image.js");
const _aspectratiosupport = require("./utils/aspect-ratio-support.js");
const _platform = require("./utils/platform.js");
const _videocssmistica = require("./video.css-mistica.js");
const _imagecssmistica = require("./image.css-mistica.js");
const _dom = require("./utils/dom.js");
const _classnames = /*#__PURE__*/ _interop_require_default(require("classnames"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
function _object_without_properties(source, excluded) {
    if (source == null) return {};
    var target = _object_without_properties_loose(source, excluded);
    var key, i;
    if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for(i = 0; i < sourceSymbolKeys.length; i++){
            key = sourceSymbolKeys[i];
            if (excluded.indexOf(key) >= 0) continue;
            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
            target[key] = source[key];
        }
    }
    return target;
}
function _object_without_properties_loose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for(i = 0; i < sourceKeys.length; i++){
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        target[key] = source[key];
    }
    return target;
}
const q = {
    loading: {
        play: "playing",
        pause: "paused",
        fail: "error",
        finishLoad: "loaded"
    },
    /**
   * This state represents the scenario when video.load() finishes, but the video isn't played yet. Some browsers don't actually load
   * the video until someone plays it. In this case, we need to show the poster, because we may not have the first frame to display it.
   * https://stackoverflow.com/questions/10235919/the-canplay-canplaythrough-events-for-an-html5-video-are-not-called-on-firefox/26430919#26430919
   */ loaded: {
        play: "playing",
        pause: "paused",
        reset: "loading"
    },
    playing: {
        pause: "paused",
        reset: "loading",
        stop: "stopped"
    },
    paused: {
        play: "playing",
        reset: "loading",
        stop: "stopped"
    },
    error: {
        reset: "loading"
    },
    stopped: {
        play: "playing",
        reset: "loading"
    }
}, D = (s, u)=>q[s][u] || s, K = {
    "1:1": 1,
    "16:9": 16 / 9,
    "4:3": 4 / 3
}, M = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAAtJREFUGFdjYAACAAAFAAGq1chRAAAAAElFTkSuQmCC", _ = /*#__PURE__*/ _react.forwardRef((_param, A)=>{
    var { src: s, poster: u, autoPlay: g = "when-loaded", muted: N = !0, loop: k = !0, preload: x = "none", loadingTimeout: b = 1e4, onLoad: y, onError: h, onPause: w, onPlay: v, aspectRatio: c = 0, dataAttributes: U } = _param, n = _object_without_properties(_param, [
        "src",
        "poster",
        "autoPlay",
        "muted",
        "loop",
        "preload",
        "loadingTimeout",
        "onLoad",
        "onError",
        "onPause",
        "onPlay",
        "aspectRatio",
        "dataAttributes"
    ]);
    const [l, o] = _react.useReducer(D, "loading"), i = _react.useRef(null), T = _react.useRef(), f = _react.useRef(null), p = n.width && n.height ? void 0 : typeof c == "number" ? c : K[c], R = _react.useCallback(()=>{
        l === "loading" && (o("fail"), h == null || h());
    }, [
        h,
        l
    ]);
    _react.useEffect(()=>{
        var e;
        if (T.current !== s) {
            let t;
            return T.current = s, o("reset"), s ? (t = setTimeout(R, b), (e = i.current) == null || e.load()) : o("fail"), ()=>{
                clearTimeout(t);
            };
        }
    }, [
        s,
        b,
        R
    ]);
    const C = ()=>{
        if (y == null || y(), l === "stopped") return;
        const e = i.current, t = g && !(0, _platform.isRunningAcceptanceTest)();
        o("finishLoad"), e && t && e.paused && e.play();
    }, V = (Array.isArray(s) ? s : [
        s
    ]).map((e)=>typeof e == "string" ? {
            src: e
        } : e), m = [
        "error",
        "loading",
        "loaded",
        "stopped"
    ].includes(l), j = /* @__PURE__ */ (0, _jsxruntime.jsx)("video", {
        ref: i,
        playsInline: !0,
        disablePictureInPicture: !0,
        disableRemotePlayback: !0,
        muted: N,
        loop: k,
        className: (0, _classnames.default)(_videocssmistica.video, _imagecssmistica.defaultBorderRadius),
        preload: x,
        onError: R,
        onPause: ()=>{
            w == null || w(), o("pause");
        },
        onTimeUpdate: ()=>{
            var e;
            l !== "playing" && ((e = i.current) == null ? void 0 : e.currentTime) !== 0 && (v == null || v(), o("play"));
        },
        onCanPlay: ()=>{
            g === "streaming" && C();
        },
        onCanPlayThrough: ()=>{
            g !== "streaming" && C();
        },
        poster: M,
        style: {
            visibility: m ? "hidden" : "visible",
            position: m || p !== 0 ? "absolute" : "static",
            width: "100%",
            height: "100%"
        },
        children: V.map((param, r)=>{
            let { src: e, type: t } = param;
            return /* @__PURE__ */ (0, _jsxruntime.jsx)("source", {
                src: e,
                type: t
            }, r);
        })
    }), I = !!(p !== 0 || n.width && n.height), E = l === "error", B = _react.useMemo(()=>u ? /* @__PURE__ */ (0, _jsxruntime.jsx)(_image.ImageContent, {
            aspectRatio: c,
            width: n.width,
            height: n.height,
            src: u
        }) : I ? /* @__PURE__ */ (0, _jsxruntime.jsx)("div", {
            style: {
                position: "absolute",
                width: "100%",
                height: "100%"
            },
            children: /* @__PURE__ */ (0, _jsxruntime.jsx)(_image.ImageError, {
                className: _imagecssmistica.defaultBorderRadius,
                withIcon: E
            })
        }) : void 0, [
        c,
        n.height,
        n.width,
        E,
        u,
        I
    ]);
    return /* @__PURE__ */ (0, _jsxruntime.jsxs)(_aspectratiosupport.AspectRatioContainer, {
        style: {
            position: "relative"
        },
        aspectRatio: p,
        width: n.width,
        height: n.height,
        dataAttributes: (0, _dom.getPrefixedDataAttributes)(U, "Video"),
        children: [
            /* @__PURE__ */ (0, _jsxruntime.jsx)("div", {
                style: {
                    position: "absolute",
                    width: "100%",
                    height: "100%"
                },
                ref: (e)=>{
                    const t = e || null;
                    t && (t.play = ()=>{
                        var r;
                        return ((r = i.current) == null ? void 0 : r.play()) || Promise.resolve();
                    }, t.pause = ()=>{
                        var r;
                        return (r = i.current) == null ? void 0 : r.pause();
                    }, t.load = ()=>{
                        var r;
                        (r = f.current) != null && r.style && (f.current.style.width = "100%", f.current.style.height = "100%"), setTimeout(()=>{
                            var F;
                            o("reset"), (F = i.current) == null || F.load();
                        }, 100);
                    }, t.setCurrentTime = (r)=>{
                        i.current && (i.current.currentTime = r);
                    }, t.stop = ()=>{
                        i.current && (i.current.pause(), i.current.currentTime = 0, o("stop"));
                    }), typeof A == "function" ? A(t) : A && (A.current = t);
                }
            }),
            j,
            /* @__PURE__ */ (0, _jsxruntime.jsx)("div", {
                ref: f,
                style: {
                    position: p !== 0 ? "absolute" : "static",
                    width: m ? "100%" : 0,
                    height: m ? "100%" : 0,
                    overflow: "hidden"
                },
                children: B
            })
        ]
    });
}), re = _;
